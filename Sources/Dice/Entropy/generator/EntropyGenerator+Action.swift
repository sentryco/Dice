import Foundation
import CryptoKit
/**
 * Actions
 */
extension EntropyGenerator {
   /**
    * Generates a cryptographically random nonce string of a given length and character set.
    * - Description: This method generates a cryptographically secure random
    *                nonce string. The length and character set of the string
    *                can be specified. If the 'unique' parameter is set to true,
    *                the method ensures that no character is repeated in the
    *                generated string.
    * - Remark: Length must be more than 0.
    * - Remark: The system may run out of entropy, so be cautious how much
    *           you query this method.
    * - Remark: This method essentially traverses through random indices
    *           generated by a "crypto-secure-random-generator" method
    *           provided by Apple.
    * Ref: Adapted from https://auth0.com/docs/api-auth/tutorials/nonce#generate-a-cryptographically-random-nonce
    * ## Examples:
    *  print(String.randomNonceString(length: 5)) // ba33H
    * - Parameters:
    *   - length: The length of the random string to generate.
    *   - charSet: The characters to include in the random string.
    *   - unique: If true, the generated string will not contain repeated characters.
    * - Throws: An error if the generated string does not match the expected length.
    * - Returns: A cryptographically random nonce string of the specified length and character set.
    */
   public static func randomNonceString(length: Int, charSet: [String] = defaultStrSet, unique: Bool = false) throws -> String {
      guard length > 0 else { throw NSError(domain: "⚠️️ Length must be longer than 0", code: 0) } // Check if the length is greater than 0
      let retArr: [String] = try ranNonceArr(
         length: length, // The length of the random string to generate
         charSet: charSet, // The characters to include in the random string
         unique: unique // If true, the generated string will not contain repeated characters
      ) // Generate an array of random string characters
      let retVal: String = retArr.joined() // Join the array of characters into a single string
      if retVal.count != length { // Check if the length of the generated string matches the expected length
         throw NSError(domain: "Err ⚠️️ retVal.count: \(retVal.count) length: \(length)", code: 0) // Throw an error if the length does not match
      }
      return retVal // Return the generated random string
   }
   /**
    * Generates a random string of a given length and character set
    * - Description: This method generates an array of random strings. The
    *                length and character set of the strings can be specified.
    *                If the 'unique' parameter is set to true, the method
    *                ensures that no character is repeated in the generated
    *                strings.
    * - Parameters:
    *   - length: The length of the random string to generate.
    *   - charSet: The characters to include in the random string.
    *   - unique: If true, the generated string will not contain repeated characters.
    * - Returns: A random string of the specified length and character set.
    * ## Example:
    *   let arr = ranNonceArr(length: 10, charSet: .defaultStrSet, unique: true)
    *   print(arr.joined()) // "j5LbKv9zEh"
    */
   public static func ranNonceArr(length: Int, charSet: [String] = defaultStrSet, unique: Bool = false) throws -> [String] {
      guard length > 0 else { throw NSError(domain: "⚠️️ Length must be longer than 0", code: 0) } // Check if the length is greater than 0
      var result: [String] = []
      var usedIndices: Set<UInt8> = Set() // Initialize an empty set for tracking used indices (for uniqueness)
      for _ in 0..<length {
        var uniqueRandom: UInt8
        repeat {
          let randomBytes: [UInt8] = try generateRandomBytes(
            count: min(16, length - result.count), // The number of random bytes to generate, which is the minimum of 16 or the remaining length
            charSetCount: charSet.count // The count of characters in the character set
         )  // Generate an array of random bytes, with the count being the minimum of 16 or the remaining length, and the character set count
          uniqueRandom = randomBytes[0]
        } while unique && !usedIndices.insert(uniqueRandom).inserted
        result.append(charSet[Int(uniqueRandom)])
      }
      return result
   }
   /**
    * Helper function to generate an array of random bytes
    * - Abstract: Generates an array of random bytes using the system's secure random number generator.
    * - Description: This function is a helper for generating random data, such as nonces or keys.
    * - Parameters:
    *   - count: The number of random bytes to generate.
    *   - charSetCount: The count of characters in the character set.
    * - Throws: An error if the random byte generation was unsuccessful.
    * - Returns: An array of random bytes.
    */
   private static func generateRandomBytes(count: Int, charSetCount: Int) throws -> [UInt8] {
      var randoms: [UInt8] = []// Initialize an empty array to store random bytes
      randoms.reserveCapacity(count) // Preallocate memory for efficiency
      while randoms.count < count { // This loop iterates 'count' number of times.
         var batchRandoms = [UInt8](repeating: 0, count: count - randoms.count)
         let errCode = SecRandomCopyBytes( // Generate a random byte using the system's secure random number generator
            kSecRandomDefault,  // The default random number generator.
            batchRandoms.count,  // The number of bytes to generate.
            &batchRandoms  // The address of the variable to store the generated random byte.
         )
         guard errCode == errSecSuccess else {  // Check if the random byte generation was successful
            throw NSError(domain: "⚠️️ Unable to generate nonce. SecRandomCopyBytes failed with OSStatus \(errCode)", code: 0) // Throw an error if the random byte could not be generated
         }
         randoms.append(contentsOf: batchRandoms.filter { Int($0) < charSetCount })
      }
      return Array(randoms.prefix(count)) // Return the array of random bytes
   }
}
